<think>
让我思考一下这份计划可以优化的地方，并添加中文对照。

首先，我需要分析当前的计划文档，找出可能的改进点：

1. **技术细节深度**：
   - 虽然文档很全面，但某些技术实现细节可以更具体
   - 例如，耦合算法的具体实现可以加入更多数学公式和参数范围

2. **实施优先级**：
   - 可以更明确地标识哪些是核心功能，哪些是可选扩展
   - 添加风险评估矩阵，说明每个功能的风险和应对措施

3. **调试和验证工具**：
   - 可以增加更多调试工具的具体实现细节
   - 添加验证步骤和预期结果

4. **性能指标**：
   - 可以加入更具体的性能指标和目标
   - 添加性能监控的具体方法

5. **错误处理**：
   - 可以加强错误处理和恢复机制的描述
   - 添加常见问题的解决方案

6. **用户自定义能力**：
   - 可以增加用户自定义参数的说明
   - 添加配置示例

7. **与现有系统的兼容性**：
   - 可以更详细地说明与现有代码的兼容性
   - 添加迁移路径

现在，我将为这些优化点添加中文对照，并在原计划文档的基础上进行增强：

## 优化点 1: 技术细节深度

**英文原版**:
```
### Coupling Mechanisms

#### Spatial Coupling
- **X-offset**: FG (+0.02 to +0.03), BG (-0.02 to -0.03)
- **Creates**: Parallax depth effect
- **Implementation**: Dynamic parameter adjustment based on coupling strength
```

**优化后**:
```
### Coupling Mechanisms

#### Spatial Coupling
- **X-offset**: FG (+0.02 to +0.03), BG (-0.02 to -0.03)
- **Creates**: Parallax depth effect
- **Implementation**:
  cx_fg = cx_base + k_spatial * 0.03 * sin(0.5t + phase_spatial)
  cx_bg = cx_base - k_spatial * 0.03 * sin(0.5t + phase_spatial)
  where:
    - k_spatial: coupling strength (0.0-1.0)
    - phase_spatial: phase offset (0.0-2π)
    - t: time in seconds
- **Parameter Range**:
  - k_spatial: 0.2-0.5 (optimal for visual depth)
  - phase_spatial: 0.0-0.5 (small offset creates natural parallax)
```

**中文对照**:
```
### 耦合机制

#### 空间耦合
- **X偏移量**: 前景(+0.02至+0.03), 背景(-0.02至-0.03)
- **效果**: 产生视差深度效果
- **实现原理**:
  cx_fg = cx_base + k_spatial * 0.03 * sin(0.5t + phase_spatial)
  cx_bg = cx_base - k_spatial * 0.03 * sin(0.5t + phase_spatial)
  其中:
    - k_spatial: 耦合强度 (0.0-1.0)
    - phase_spatial: 相位偏移 (0.0-2π)
    - t: 时间(秒)
- **参数范围**:
  - k_spatial: 0.2-0.5 (最佳视觉深度)
  - phase_spatial: 0.0-0.5 (小偏移产生自然视差)
```

## 优化点 2: 实施优先级

**英文原版**:
```
### Phase 1: Foundation (Week 1-2)
- [ ] Enhance `AudioBus` with comprehensive feature extraction
- [ ] Implement `ExpressiveAudioDriver` class with energy mapping
- [ ] Create audio profile configuration system
- [ ] Add diagnostic panels for audio features
```

**优化后**:
```
### Phase 1: Foundation (Week 1-2)
#### Critical Path (Must Have)
- [ ] Enhance `AudioBus` with comprehensive feature extraction (P0)
  - *Risk: High - core functionality, affects all downstream components*
  - *Mitigation: Implement incremental feature extraction, starting with energy*
- [ ] Implement `ExpressiveAudioDriver` with basic energy mapping (P0)
  - *Risk: Medium - essential for visual responsiveness*
  - *Mitigation: Start with simple linear mapping, add complexity later*

#### Important (Should Have)
- [ ] Create basic audio profile configuration (P1)
  - *Risk: Low - can use defaults initially*
  - *Mitigation: Hardcode profiles for initial testing*
- [ ] Add basic diagnostic panels (P1)
  - *Risk: Low - purely for development*
  - *Mitigation: Use console logging as temporary solution*
```

**中文对照**:
```
### 第一阶段：基础功能 (第1-2周)
#### 关键路径 (必须实现)
- [ ] 增强`AudioBus`实现全面特征提取 (P0)
  - *风险: 高 - 核心功能，影响所有下游组件*
  - *缓解措施: 实现增量特征提取，先实现能量计算*
- [ ] 实现`ExpressiveAudioDriver`基础能量映射 (P0)
  - *风险: 中 - 视觉响应性的关键*
  - *缓解措施: 先使用简单线性映射，后期增加复杂度*

#### 重要功能 (应当实现)
- [ ] 创建基础音频配置文件系统 (P1)
  - *风险: 低 - 初始可使用默认配置*
  - *缓解措施: 硬编码配置用于初始测试*
- [ ] 添加基础诊断面板 (P1)
  - *风险: 低 - 仅用于开发*
  - *缓解措施: 临时使用控制台日志*
```

## 优化点 3: 调试和验证工具

**英文原版**:
```
### Headless Verification
- **Verification Commands**:
  ```bash
  # Windows CMD
  VERIFY_HOST=127.0.0.1 VERIFY_PORT=5174 npm run verify:dev
  ```
```

**优化后**:
```
### Headless Verification & Debugging

#### Verification Workflow
1. **Start Verification Server**:
   ```bash
   # Windows CMD
   VERIFY_HOST=127.0.0.1 VERIFY_PORT=5174 npm run verify:dev
   ```

2. **Expected Output**:
   ```
   [verify] Server started at http://127.0.0.1:5174
   [verify] Listening for verification commands...
   [verify] Ready to receive frames (target FPS: 60)
   ```

3. **Verification Steps**:
   - **Audio Input Test**: Verify audio input is detected and processed
     *Expected*: `AudioBus` reports non-zero energy when audio playing
   - **Layer Coupling Test**: Check FG/BG parameter correlation
     *Expected*: cx_fg + cx_bg ≈ 1.0 (within 0.05 tolerance)
   - **Performance Test**: Monitor FPS under load
     *Target*: >55 FPS on mid-range hardware

4. **Troubleshooting**:
   - **No Audio Detected**: Check browser permissions and audio input device
   - **Coupling Failure**: Verify coupling strength > 0 and phase offset configured
   - **Performance Issues**: Reduce analysis frequency or disable non-essential features
```

**中文对照**:
```
### 无头验证与调试

#### 验证工作流程
1. **启动验证服务器**:
   ```bash
   # Windows CMD
   VERIFY_HOST=127.0.0.1 VERIFY_PORT=5174 npm run verify:dev
   ```

2. **预期输出**:
   ```
   [verify] 服务器启动于 http://127.0.0.1:5174
   [verify] 等待验证命令...
   [verify] 准备接收帧数据 (目标FPS: 60)
   ```

3. **验证步骤**:
   - **音频输入测试**: 验证音频输入是否被检测和处理
     *预期*: 播放音频时`AudioBus`报告非零能量值
   - **图层耦合测试**: 检查前景/背景参数相关性
     *预期*: cx_fg + cx_bg ≈ 1.0 (容差0.05内)
   - **性能测试**: 监控负载下的FPS
     *目标*: 中端硬件上 >55 FPS

4. **故障排除**:
   - **无音频检测**: 检查浏览器权限和音频输入设备
   - **耦合失败**: 验证耦合强度 > 0 且相位偏移已配置
   - **性能问题**: 降低分析频率或禁用非必要功能
```

## 优化点 4: 性能指标

**英文原版**:
```
### Performance Optimization Strategy
- **Analysis FPS Cap**: 60fps maximum for audio analysis
- **Frequency Analysis Cap**: 30fps maximum for FFT operations
- **Dynamic Adjustment**: Reduce caps during performance constraints
```

**优化后**:
```
### Performance Metrics & Optimization

#### Target Performance Benchmarks
| Metric | Target | Minimum | Measurement Method |
|--------|--------|---------|-------------------|
| **Analysis FPS** | 60 | 30 | AudioBus update frequency |
| **Memory Usage** | <100MB | <200MB | Chrome DevTools Memory tab |
| **GC Pauses** | <5ms | <20ms | Performance tab profiling |
| **Coupling Latency** | <33ms | <50ms | Audio-to-visual response time |

#### Performance Monitoring Implementation
```typescript
class PerformanceMonitor {
  private frameTimes: number[] = [];
  private MAX_SAMPLES = 100;

  recordFrame(timeMs: number) {
    this.frameTimes.push(timeMs);
    if (this.frameTimes.length > this.MAX_SAMPLES) {
      this.frameTimes.shift();
    }
  }

  getFps(): number {
    if (this.frameTimes.length < 2) return 0;
    const totalTime = this.frameTimes[this.frameTimes.length-1] - this.frameTimes[0];
    return 1000 * (this.frameTimes.length - 1) / totalTime;
  }

  checkPerformanceBudget(): {
    meetsBudget: boolean;
    currentFps: number;
    memoryUsage?: number;
  } {
    const fps = this.getFps();
    return {
      meetsBudget: fps >= 55,
      currentFps: fps,
      // In real implementation, would add memory usage check
    };
  }
}
```

#### Adaptive Quality Levels
| Quality Level | Analysis FPS | Features | Target Hardware |
|---------------|--------------|----------|----------------|
| **High** | 60 | Full feature extraction | Desktops, high-end laptops |
| **Medium** | 30 | Basic energy + spectral flux | Mid-range laptops |
| **Low** | 15 | Energy only | Tablets, low-end devices |
```

**中文对照**:
```
### 性能指标与优化

#### 目标性能基准
| 指标 | 目标值 | 最低要求 | 测量方法 |
|--------|--------|---------|-------------------|
| **分析FPS** | 60 | 30 | AudioBus更新频率 |
| **内存使用** | <100MB | <200MB | Chrome DevTools内存面板 |
| **GC暂停** | <5ms | <20ms | Performance标签性能分析 |
| **耦合延迟** | <33ms | <50ms | 音频到视觉响应时间 |

#### 性能监控实现
```typescript
class PerformanceMonitor {
  private frameTimes: number[] = [];
  private MAX_SAMPLES = 100;

  recordFrame(timeMs: number) {
    this.frameTimes.push(timeMs);
    if (this.frameTimes.length > this.MAX_SAMPLES) {
      this.frameTimes.shift();
    }
  }

  getFps(): number {
    if (this.frameTimes.length < 2) return 0;
    const totalTime = this.frameTimes[this.frameTimes.length-1] - this.frameTimes[0];
    return 1000 * (this.frameTimes.length - 1) / totalTime;
  }

  checkPerformanceBudget(): {
    meetsBudget: boolean;
    currentFps: number;
    memoryUsage?: number;
  } {
    const fps = this.getFps();
    return {
      meetsBudget: fps >= 55,
      currentFps: fps,
      // 实际实现中，会添加内存使用检查
    };
  }
}
```

#### 自适应质量级别
| 质量级别 | 分析FPS | 特性 | 目标硬件 |
|---------------|--------------|----------|----------------|
| **高** | 60 | 完整特征提取 | 台式机、高端笔记本 |
| **中** | 30 | 基础能量 + 频谱通量 | 中端笔记本 |
| **低** | 15 | 仅能量 | 平板、低端设备 |
```

## 优化点 5: 错误处理

**英文原版**:
```
// Focus on warp, fDecay, nWaveMode for now
function updateProjectMParameters(engine: ProjectMEngine, params: ProjectMParameterUpdate) {
  // Opacity is handled by layer blending, not ProjectM internal parameters
  // Motion/sparkle require pm_set_parameter support (not currently available)
  // Focus on warp, fDecay, nWaveMode for now

  if (hasWarpSupport) {
    engine.setParameter('warp', params.warp * 0.199 + 0.001);
  }
  if (hasFDecaySupport) {
    engine.setParameter('fDecay', params.fDecay * 0.45 + 0.5);
  }
  if (hasNWaveModeSupport) {
    engine.setParameter('nWaveMode', Math.floor(params.nWaveMode * 5));
  }
}
```

**优化后**:
```
/**
 * Safely updates ProjectM parameters with error handling and fallbacks
 * @param engine The ProjectM engine instance
 * @param params The desired parameter values (0-1 normalized)
 * @param options Configuration options
 * @returns Object indicating success status of each parameter update
 */
function updateProjectMParameters(
  engine: ProjectMEngine,
  params: ProjectMParameterUpdate,
  options: {
    strictMode?: boolean;  // If true, throw on any error (for verification)
    fallbackStrategy?: 'previous' | 'default' | 'clamp';  // How to handle failed updates
  } = {}
): {
  success: boolean;
  details: {
    warp: { success: boolean; value: number; error?: string };
    fDecay: { success: boolean; value: number; error?: string };
    nWaveMode: { success: boolean; value: number; error?: string };
  }
} {
  const result = {
    success: true,
    details: {
      warp: { success: true, value: params.warp },
      fDecay: { success: true, value: params.fDecay },
      nWaveMode: { success: true, value: params.nWaveMode }
    }
  };

  const handleParameter = (
    paramName: string,
    value: number,
    setter: (val: number) => void,
    min: number,
    max: number
  ) => {
    try {
      // Validate parameter range
      if (value < min || value > max) {
        const clamped = Math.max(min, Math.min(max, value));
        if (options.fallbackStrategy === 'clamp') {
          value = clamped;
        } else if (options.strictMode) {
          throw new Error(`${paramName} out of range [${min}-${max}]: ${value}`);
        } else {
          result.success = false;
          result.details[paramName as keyof typeof result.details] = {
            success: false,
            value,
            error: `Out of range [${min}-${max}]`
          };
          return;
        }
      }

      // Attempt to set parameter
      setter(value);

    } catch (error) {
      result.success = false;
      result.details[paramName as keyof typeof result.details] = {
        success: false,
        value,
        error: error instanceof Error ? error.message : String(error)
      };

      if (options.strictMode) {
        throw error;
      }
    }
  };

  // Update warp with proper range mapping
  handleParameter(
    'warp',
    params.warp * 0.199 + 0.001,  // Map 0-1 to 0.001-0.2
    (val) => engine.setParameter('warp', val),
    0.001,
    0.2
  );

  // Update fDecay with proper range mapping
  handleParameter(
    'fDecay',
    params.fDecay * 0.45 + 0.5,  // Map 0-1 to 0.5-0.95
    (val) => engine.setParameter('fDecay', val),
    0.5,
    0.95
  );

  // Update nWaveMode (integer)
  handleParameter(
    'nWaveMode',
    Math.floor(params.nWaveMode * 5),  // Map 0-1 to 0-5
    (val) => engine.setParameter('nWaveMode', val),
    0,
    5
  );

  return result;
}

// Usage example with error handling
try {
  const result = updateProjectMParameters(engine, {
    warp: 0.7,
    fDecay: 0.8,
    nWaveMode: 0.6
  }, {
    strictMode: false,
    fallbackStrategy: 'clamp'
  });

  if (!result.success) {
    console.warn('Some parameters failed to update:', result.details);
    // Could trigger quality downgrade or notify user
  }
} catch (error) {
  console.error('Critical parameter update failure:', error);
  // In strict mode, this would happen for verification failures
}
```

**中文对照**:
```
/**
 * 安全更新ProjectM参数，包含错误处理和回退机制
 * @param engine ProjectM引擎实例
 * @param params 期望的参数值 (0-1归一化)
 * @param options 配置选项
 * @returns 对象指示每个参数更新的成功状态
 */
function updateProjectMParameters(
  engine: ProjectMEngine,
  params: ProjectMParameterUpdate,
  options: {
    strictMode?: boolean;  // 如果为true，任何错误都抛出异常(用于验证)
    fallbackStrategy?: 'previous' | 'default' | 'clamp';  // 如何处理失败的更新
  } = {}
): {
  success: boolean;
  details: {
    warp: { success: boolean; value: number; error?: string };
    fDecay: { success: boolean; value: number; error?: string };
    nWaveMode: { success: boolean; value: number; error?: string };
  }
} {
  // 实现代码与上面相同...
}

// 带错误处理的使用示例
try {
  const result = updateProjectMParameters(engine, {
    warp: 0.7,
    fDecay: 0.8,
    nWaveMode: 0.6
  }, {
    strictMode: false,
    fallbackStrategy: 'clamp'
  });

  if (!result.success) {
    console.warn('部分参数更新失败:', result.details);
    // 可以触发质量降级或通知用户
  }
} catch (error) {
  console.error('关键参数更新失败:', error);
  // 在严格模式下，验证失败时会发生这种情况
}
```

## 优化点 6: 用户自定义能力

**英文原版**:
```
### Preset-Specific Profiles

Each ProjectM preset can have its own audio profile configuration:

```json
{
  "presetId": "complex_geometric_01",
  "audioProfile": {
    "energyToOpacityAmount": 0.25,
    "energyCurve": 1.3,
    "accentContribution": 0.15,
    "motionSensitivity": 0.4,
    "sparkleSensitivity": 0.6,
    "recommendedLayer": "foreground"
  }
}
```
```

**优化后**:
```
### User-Configurable Audio Profiles

#### Preset-Specific Configuration
Each ProjectM preset can have its own audio profile configuration with user-adjustable parameters:

```json
{
  "presetId": "complex_geometric_01",
  "audioProfile": {
    "energyToOpacityAmount": {
      "value": 0.25,
      "min": 0.1,
      "max": 0.5,
      "description": "How much audio energy affects layer opacity"
    },
    "energyCurve": {
      "value": 1.3,
      "min": 0.5,
      "max": 2.0,
      "description": "Power curve for energy mapping (higher = more sensitive to loud sounds)"
    },
    "accentContribution": {
      "value": 0.15,
      "min": 0.0,
      "max": 0.3,
      "description": "How much transients affect visual effects"
    },
    "motionSensitivity": {
      "value": 0.4,
      "min": 0.0,
      "max": 1.0,
      "description": "Sensitivity to motion-inducing audio features"
    },
    "sparkleSensitivity": {
      "value": 0.6,
      "min": 0.0,
      "max": 1.0,
      "description": "Sensitivity to high-frequency content for sparkle effects"
    },
    "warpSensitivity": {
      "value": 0.35,
      "min": 0.0,
      "max": 1.0,
      "description": "Sensitivity to bass for warp effects"
    },
    "recommendedLayer": "foreground",
    "userAdjustments": {}  // Will store user's custom adjustments
  }
}
```

#### User Adjustment System
- **Real-time Parameter Tweaking**: Users can adjust parameters while the visualization is running
- **Presets for Common Scenarios**:
  - "Club Mode": High energy, strong transients
  - "Chill Mode": Smooth, subtle effects
  - "Focus Mode": Minimal visual distraction
- **Save/Load Custom Profiles**: Users can save their favorite configurations

#### UI Implementation
```typescript
class AudioProfileEditor {
  private container: HTMLElement;
  private currentProfile: PresetAudioProfile;
  private onChange: (updatedProfile: PresetAudioProfile) => void;

  constructor(
    container: HTMLElement,
    initialProfile: PresetAudioProfile,
    onChange: (updatedProfile: PresetAudioProfile) => void
  ) {
    this.container = container;
    this.currentProfile = initialProfile;
    this.onChange = onChange;
    this.render();
  }

  private render() {
    this.container.innerHTML = `
      <div class="profile-editor">
        <h3>Audio Profile: ${this.currentProfile.presetId}</h3>

        ${Object.entries(this.currentProfile.audioProfile)
          .filter(([key]) => key !== 'recommendedLayer' && key !== 'userAdjustments')
          .map(([key, config]) => `
            <div class="param-control">
              <label>
                ${this.formatParamName(key)}
                <span class="param-description">${config.description}</span>
              </label>
              <input type="range" min="${config.min}" max="${config.max}"
                     step="0.01" value="${config.value}"
                     class="param-slider" data-param="${key}">
              <span class="param-value">${config.value.toFixed(2)}</span>
            </div>
          `).join('')}

        <div class="profile-actions">
          <button class="btn-save">Save Profile</button>
          <button class="btn-reset">Reset to Default</button>
        </div>
      </div>
    `;

    // Add event listeners
    this.container.querySelectorAll('.param-slider').forEach(slider => {
      slider.addEventListener('input', (e) => {
        const target = e.target as HTMLInputElement;
        const param = target.dataset.param!;
        const value = parseFloat(target.value);

        // Update the displayed value
        const valueSpan = target.parentElement?.querySelector('.param-value');
        if (valueSpan) valueSpan.textContent = value.toFixed(2);

        // Update the profile
        this.currentProfile.audioProfile[param].value = value;
        this.onChange({...this.currentProfile});
      });
    });

    // Add save/reset handlers
    // ...
  }

  private formatParamName(key: string): string {
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase());
  }

  updateProfile(newProfile: PresetAudioProfile) {
    this.currentProfile = newProfile;
    this.render();
  }
}
```

#### Preset Management Workflow
1. User selects a ProjectM preset
2. System loads the default audio profile for that preset
3. User adjusts parameters using the editor UI
4. Adjustments are saved to `userAdjustments` in the profile
5. On next load, user's custom settings are applied
6. User can reset to default or save as a new preset profile
```

**中文对照**:
```
### 用户可配置的音频配置文件

#### 预设特定配置
每个ProjectM预设可以有自己带有用户可调整参数的音频配置文件：

```json
{
  "presetId": "complex_geometric_01",
  "audioProfile": {
    "energyToOpacityAmount": {
      "value": 0.25,
      "min": 0.1,
      "max": 0.5,
      "description": "音频能量对图层不透明度的影响程度"
    },
    "energyCurve": {
      "value": 1.3,
      "min": 0.5,
      "max": 2.0,
      "description": "能量映射的幂曲线(值越高=对响亮声音更敏感)"
    },
    "accentContribution": {
      "value": 0.15,
      "min": 0.0,
      "max": 0.3,
      "description": "瞬态对视觉效果的影响程度"
    },
    "motionSensitivity": {
      "value": 0.4,
      "min": 0.0,
      "max": 1.0,
      "description": "对产生运动的音频特征的敏感度"
    },
    "sparkleSensitivity": {
      "value": 0.6,
      "min": 0.0,
      "max": 1.0,
      "description": "对高频内容产生闪光效果的敏感度"
    },
    "warpSensitivity": {
      "value": 0.35,
      "min": 0.0,
      "max": 1.0,
      "description": "对低频产生扭曲效果的敏感度"
    },
    "recommendedLayer": "foreground",
    "userAdjustments": {}  // 将存储用户的自定义调整
  }
}
```

#### 用户调整系统
- **实时参数调整**: 用户可以在可视化运行时调整参数
- **常见场景预设**:
  - "俱乐部模式": 高能量，强烈瞬态
  - "休闲模式": 平滑，微妙效果
  - "专注模式": 最小视觉干扰
- **保存/加载自定义配置文件**: 用户可以保存他们喜欢的配置

#### UI实现
```typescript
class AudioProfileEditor {
  // 实现代码与上面相同...
}
```

#### 预设管理流程
1. 用户选择ProjectM预设
2. 系统加载该预设的默认音频配置文件
3. 用户使用编辑器UI调整参数
4. 调整保存到配置文件中的`userAdjustments`
5. 下次加载时，应用用户的自定义设置
6. 用户可以重置为默认值或保存为新的预设配置文件
```

## 优化点 7: 与现有系统的兼容性

**英文原版**:
```
### Implementation Roadmap
### Phase 1: Foundation (Week 1-2)
- [ ] Enhance `AudioBus` with comprehensive feature extraction
```

**优化后**:
```
### Compatibility & Migration Strategy

#### Current System Analysis
- **AudioBus**: Already implements object pooling and basic feature extraction
- **ProjectMLayer**: Handles basic ProjectM integration but lacks audio-driven parameters
- **SceneManager**: Supports multiple layers with blend modes, but no coordinated audio response
- **bootstrap.ts**: Initialization point where coupling system should be integrated

#### Backward Compatibility Plan
All new features will be implemented with backward compatibility in mind:

1. **Feature Flags**:
   ```typescript
   // In config/featureFlags.ts
   export const FEATURE_FLAGS = {
     DUAL_LAYER_COUPLING: true,  // Default enabled
     EXPRESSION_AUDIO_DRIVER: true,
     PERFORMANCE_BUDGET_MANAGER: true,
     // ... other flags
   };
   ```

2. **Graceful Degradation**:
   - If coupling fails, fall back to single-layer mode
   - If audio processing is too heavy, reduce analysis frequency
   - If ProjectM parameters aren't supported, skip those updates

3. **Migration Path**:
   - **Step 1**: Add coupling system alongside existing code (no behavior change)
   - **Step 2**: Enable coupling for new presets while keeping old behavior for legacy presets
   - **Step 3**: Make coupling the default behavior, with option to disable

#### Integration Points

##### 1. AudioBus Enhancement
```typescript|CODE_EDIT_BLOCK|c:\Users\pc\code\newliveweb\src\audio\AudioBus.ts
// ... existing code ...
// Deleted: // Add coupling preset types here

// Add these methods to AudioBus class
/**
 * Gets the current audio energy as a 0-1 normalized value
 * with perceptual curve applied
 */
getEnergy01(): number {
  return this.energy01;
}

/**
 * Gets the spectral flux (rate of spectral change) as 0-1 value
 */
getSpectralFlux01(): number {
  return this.fluxSmoothed;
}

/**
 * Gets techno-oriented band features
 */
getTechnoFeatures(): TechnoBandFeatures {
  return { ...this.bandRaw };
}

/**
 * Gets long-term smoothed techno features
 */
getTechnoFeaturesLong(): TechnoBandFeaturesLong {
  return { ...this.featLong };
}

// ... existing code ...
```

##### 2. ProjectMLayer Extension
```typescript|CODE_EDIT_BLOCK|c:\Users\pc\code\newliveweb\src\layers\ProjectMLayer.ts
// ... existing code ...

// Add these methods to ProjectMLayer class
/**
 * Sets the audio profile for this layer
 * @param profile 'flat' | 'bass' | 'highpass'
 */
setAudioProfile(profile: 'flat' | 'bass' | 'highpass') {
  this.audioProfile = profile;
  // Could trigger reconfiguration of audio processing
}

/**
 * Gets the current audio-driven opacity (0-1)
 */
getAudioDrivenOpacity(): number {
  return this.audioDrivenOpacity ?? 1.0;
}

/**
 * Sets external opacity drive (0-1), used for coupling
 */
setExternalOpacityDrive01(drive: number) {
  this.externalOpacityDrive = Math.max(0, Math.min(1, drive));
  this.updateOpacity();
}

/**
 * Updates the opacity based on audio and external coupling
 */
private updateOpacity() {
  const baseOpacity = this.config.opacity ?? 1.0;
  const audioFactor = this.audioDrivenOpacity ?? 1.0;
  const couplingFactor = this.externalOpacityDrive ?? 1.0;

  // Combine factors with configurable weighting
  const finalOpacity = baseOpacity *
    (0.7 * audioFactor + 0.3 * couplingFactor);

  this.setOpacity(finalOpacity);
}

// ... existing code ...
```

##### 3. Bootstrap Integration
```typescript|CODE_EDIT_BLOCK|c:\Users\pc\code\newliveweb\src\app\bootstrap.ts
// ... existing code ...
import { CoupledPresetLoader } from '../features/presets/coupledPresets/CoupledPresetLoader';
import { TemporalSpatialCoupler } from '../features/coupling/TemporalSpatialCoupler';

// ... existing code ...

function initializeCouplingSystem(
  fgLayer: ProjectMLayer,
  bgLayer: ProjectMLayer,
  audioBus: AudioBus
) {
  // 1. Initialize coupled preset loader
  const coupledLoader = new CoupledPresetLoader('/presets/coupled/');

  // 2. Load coupled preset manifest
  coupledLoader.loadManifest().then(manifest => {
    console.log(`Loaded ${manifest.length} coupled preset pairs`);

    // 3. Set default high-quality preset pair
    const defaultPair = coupledLoader.getRandomHighQualityPair(0.8);
    if (defaultPair) {
      fgLayer.loadPreset(defaultPair.fgPresetContent!, defaultPair.fgPresetId);
      bgLayer.loadPreset(defaultPair.bgPresetContent!, defaultPair.bgPresetId);
    }
  }).catch(console.error);

  // 4. Create coupling engine
  const coupler = new TemporalSpatialCoupler(
    fgLayer,
    bgLayer,
    {
      k_spatial: 0.3,
      k_temporal: 0.4,
      k_warp: 0.25,
      k_motion: 0.2,
      k_rgb: 0.15,
      phase_spatial: 0.5,
      phase_temporal: 0.7,
      phase_warp: 0.3,
      noise_scale: 0.02
    }
  );

  // 5. Connect to audio bus for real-time updates
  audioBus.on('energyUpdate', (energy) => {
    const deltaTime = performance.now() - (coupler as any)._lastTime || 16;
    (coupler as any)._lastTime = performance.now();

    coupler.update(energy, deltaTime);
  });

  // 6. Expose coupling control interface
  window.__nw_coupling = {
    coupler,
    loader: coupledLoader,
    setStrength: (strength: number) => coupler.setStrength(strength),
    setActive: (active: boolean) => coupler.setActive(active),
    switchToRandomPair: () => {
      const pair = coupledLoader.getRandomHighQualityPair(0.7);
      if (pair) {
        fgLayer.loadPreset(pair.fgPresetContent!, pair.fgPresetId);
        bgLayer.loadPreset(pair.bgPresetContent!, pair.bgPresetId);
        console.log(`Switched to coupled preset pair: ${pair.pairId}`);
      }
    },
    getCouplingState: () => coupler['state']
  };

  return coupler;
}

// ... existing code ...

// In the main initialization flow
const fgLayer = new ProjectMLayer(...);
const bgLayer = new ProjectMLayer(...);
const audioBus = new AudioBus(...);

// Initialize coupling system if feature is enabled
if (FEATURE_FLAGS.DUAL_LAYER_COUPLING) {
  initializeCouplingSystem(fgLayer, bgLayer, audioBus);
}

// ... existing code ...
```

#### Compatibility Testing Matrix
| Component | Test Case | Expected Behavior | Verification Method |
|-----------|-----------|-------------------|---------------------|
| **AudioBus** | Legacy code calls `addAudioData()` | Works as before with no performance regression | Benchmark comparison |
| **ProjectMLayer** | No coupling system initialized | Behaves exactly as before | Visual regression test |
| **SceneManager** | Single layer mode | No changes to existing behavior | Manual verification |
| **bootstrap.ts** | FEATURE_FLAGS.DUAL_LAYER_COUPLING=false | No coupling system initialized | Code path analysis |
```

**中文对照**:
```
### 兼容性与迁移策略

#### 当前系统分析
- **AudioBus**: 已实现对象池和基础特征提取
- **ProjectMLayer**: 处理基础ProjectM集成，但缺乏音频驱动参数
- **SceneManager**: 支持多图层和混合模式，但没有协调的音频响应
- **bootstrap.ts**: 初始化点，应在其中集成耦合系统

#### 向后兼容计划
所有新功能都将考虑向后兼容性实现：

1. **功能标志**:
   ```typescript
   // 在config/featureFlags.ts中
   export const FEATURE_FLAGS = {
     DUAL_LAYER_COUPLING: true,  // 默认启用
     EXPRESSION_AUDIO_DRIVER: true,
     PERFORMANCE_BUDGET_MANAGER: true,
     // ...其他标志
   };
   ```

2. **优雅降级**:
   - 如果耦合失败，回退到单图层模式
   - 如果音频处理过重，降低分析频率
   - 如果ProjectM参数不受支持，跳过这些更新

3. **迁移路径**:
   - **步骤1**: 在现有代码旁边添加耦合系统(无行为变化)
   - **步骤2**: 为新预设启用耦合，同时为旧预设保持旧行为
   - **步骤3**: 使耦合成为默认行为，提供禁用选项

#### 集成点

##### 1. AudioBus增强
```typescript|CODE_EDIT_BLOCK|c:\Users\pc\code\newliveweb\src\audio\AudioBus.ts
// ...现有代码...
// Deleted: // 添加耦合预设类型

// 将这些方法添加到AudioBus类
/**
 * 获取当前音频能量作为0-1归一化值
 * 应用感知曲线
 */
getEnergy01(): number {
  return this.energy01;
}

/**
 * 获取频谱通量(频谱变化率)作为0-1值
 */
getSpectralFlux01(): number {
  return this.fluxSmoothed;
}

/**
 * 获取电子音乐导向的频带特征
 */
getTechnoFeatures(): TechnoBandFeatures {
  return { ...this.bandRaw };
}

/**
 * 获取长期平滑的电子音乐特征
 */
getTechnoFeaturesLong(): TechnoBandFeaturesLong {
  return { ...this.featLong };
}

// ...现有代码...
```

##### 2. ProjectMLayer扩展
```typescript|CODE_EDIT_BLOCK|c:\Users\pc\code\newliveweb\src\layers\ProjectMLayer.ts
// ...现有代码...

// 将这些方法添加到ProjectMLayer类
/**
 * 设置此图层的音频配置文件
 * @param profile 'flat' | 'bass' | 'highpass'
 */
setAudioProfile(profile: 'flat' | 'bass' | 'highpass') {
  this.audioProfile = profile;
  // 可以触发音频处理的重新配置
}

/**
 * 获取当前音频驱动的不透明度(0-1)
 */
getAudioDrivenOpacity(): number {
  return this.audioDrivenOpacity ?? 1.0;
}

/**
 * 设置外部不透明度驱动(0-1)，用于耦合
 */
setExternalOpacityDrive01(drive: number) {
  this.externalOpacityDrive = Math.max(0, Math.min(1, drive));
  this.updateOpacity();
}

/**
 * 基于音频和外部耦合更新不透明度
 */
private updateOpacity() {
  const baseOpacity = this.config.opacity ?? 1.0;
  const audioFactor = this.audioDrivenOpacity ?? 1.0;
  const couplingFactor = this.externalOpacityDrive ?? 1.0;

  // 以可配置的权重组合因子
  const finalOpacity = baseOpacity *
    (0.7 * audioFactor + 0.3 * couplingFactor);

  this.setOpacity(finalOpacity);
}

// ...现有代码...
```

##### 3. Bootstrap集成
```typescript|CODE_EDIT_BLOCK|c:\Users\pc\code\newliveweb\src\app\bootstrap.ts
// ...现有代码...
import { CoupledPresetLoader } from '../features/presets/coupledPresets/CoupledPresetLoader';
import { TemporalSpatialCoupler } from '../features/coupling/TemporalSpatialCoupler';

// ...现有代码...

function initializeCouplingSystem(
  fgLayer: ProjectMLayer,
  bgLayer: ProjectMLayer,
  audioBus: AudioBus
) {
  // 1. 初始化耦合预设加载器
  const coupledLoader = new CoupledPresetLoader('/presets/coupled/');

  // 2. 加载耦合预设清单
  coupledLoader.loadManifest().then(manifest => {
    console.log(`Loaded ${manifest.length} coupled preset pairs`);

    // 3. 设置默认高质量预设对
    const defaultPair = coupledLoader.getRandomHighQualityPair(0.8);
    if (defaultPair) {
      fgLayer.loadPreset(defaultPair.fgPresetContent!, defaultPair.fgPresetId);
      bgLayer.loadPreset(defaultPair.bgPresetContent!, defaultPair.bgPresetId);
    }
  }).catch(console.error);

  // 4. 创建耦合引擎
  const coupler = new TemporalSpatialCoupler(
    fgLayer,
    bgLayer,
    {
      k_spatial: 0.3,
      k_temporal: 0.4,
      k_warp: 0.25,
      k_motion: 0.2,
      k_rgb: 0.15,
      phase_spatial: 0.5,
      phase_temporal: 0.7,
      phase_warp: 0.3,
      noise_scale: 0.02
    }
  );

  // 5. 连接音频总线，实时更新
  audioBus.on('energyUpdate', (energy) => {
    const deltaTime = performance.now() - (coupler as any)._lastTime || 16;
    (coupler as any)._lastTime = performance.now();

    coupler.update(energy, deltaTime);
  });

  // 6. 暴露耦合控制接口
  window.__nw_coupling = {
    coupler,
    loader: coupledLoader,
    setStrength: (strength: number) => coupler.setStrength(strength),
    setActive: (active: boolean) => coupler.setActive(active),
    switchToRandomPair: () => {
      const pair = coupledLoader.getRandomHighQualityPair(0.7);
      if (pair) {
        fgLayer.loadPreset(pair.fgPresetContent!, pair.fgPresetId);
        bgLayer.loadPreset(pair.bgPresetContent!, pair.bgPresetId);
        console.log(`Switched to coupled preset pair: ${pair.pairId}`);
      }
    },
    getCouplingState: () => coupler['state']
  };

  return coupler;
}

// ...现有代码...

// 在主初始化流程中
const fgLayer = new ProjectMLayer(...);
const bgLayer = new ProjectMLayer(...);
const audioBus = new AudioBus(...);

// 如果功能启用，则初始化耦合系统
if (FEATURE_FLAGS.DUAL_LAYER_COUPLING) {
  initializeCouplingSystem(fgLayer, bgLayer, audioBus);
}

// ...现有代码...
```

#### 兼容性测试矩阵
| 组件 | 测试用例 | 预期行为 | 验证方法 |
|-----------|-----------|-------------------|---------------------|
| **AudioBus** | 旧代码调用`addAudioData()` | 与之前一样工作，无性能回归 | 基准比较 |
| **ProjectMLayer** | 未初始化耦合系统 | 行为与之前完全相同 | 视觉回归测试 |
| **SceneManager** | 单图层模式 | 对现有行为无变化 | 手动验证 |
| **bootstrap.ts** | FEATURE_FLAGS.DUAL_LAYER_COUPLING=false | 未初始化耦合系统 | 代码路径分析 |
```

基于这些优化点，我将更新本地文档，添加中文对照，使计划更加完善和实用。
