继续 我想要的3d算法呢   给你一份报告参考:(参考实际代码情况,思考一份新的aivj的计划,关系到所有的参数)   内容: 下面继续“深度贴合你这套参数字典”的算法精细化：目标是 **更稳、更像演出系统的“控制器”**，同时画面更“酷”，但仍然 **不引大依赖**、只在 `bootstrap.ts / computeMacroPatch.ts` 里用少量状态完成。
# AIVJ（AudioBus / bootstrap / computeMacroPatch）Codex 一键执行任务拆解 + 最小 Patch（无大依赖）

> 目标：先把 **AudioBus 最小闭环**补齐（输入设备/MediaStream/源状态/seek 规则/持久化），再把 **runtime coupling + macro patch**做成“演出级稳定”的参数管线，并加入几套酷炫但轻量的算法（不引入大依赖）。

---

## 0) 约定（全局）

### 0.1 文件与路径（按你文档）

* `src/audio/AudioBus.ts`（或你实际路径：`src/audio/AudioBus.ts` / `src/audio/AudioBus.tsx`）
* `src/bootstrap.ts`
* `src/macro/computeMacroPatch.ts`
* `src/types/audioFrame.ts`（若已有 AudioFrame 类型）
* `src/utils/*`（新增轻量函数，可直接放同文件底部，避免新增文件）

### 0.2 localStorage keys（已定义）

* `newliveweb:audio:preferredSource`
* `newliveweb:audio:inputDeviceId`
* `newliveweb:audio:trackVolume`
* `newliveweb:mixxx:url`（本次不动）
* `newliveweb:ui:debugMode`（本次不动）

### 0.3 验收（全局）

* 不引入新依赖（只用 WebAudio + 原生 JS/TS）
* 音频源切换：file/url/stream 三态 UI 不乱（`currentSource` 必须可信）
* stream 下：seek/loop 规则明确、UI 能禁用 seek
* 产出的 `AudioFrame.energy` 平滑稳定、不跳、不炸（新增算法保证）
* `bootstrap.ts`：runtime coupling 不修改 state，只影响 render-time 临时值

---

# 1) Task A：AudioBus 最小闭环（最优先）

## A1. 修改文件

* `src/audio/AudioBus.ts`
* （可选）`src/types/audioFrame.ts`：补齐 `currentSource`/`inputSourceInfo` 类型

## A2. TODO 清单（可执行）

1. **补齐状态字段**（streamLabel / streamDeviceId / streamKind / currentSource）
2. **实现** `loadInputDevice(deviceId?: string)`
3. **实现** `loadMediaStream(stream: MediaStream, opts?: { label?: string })`
4. **实现** `refreshAudioInputDevices()`（如果 UI 需要；没有就先不做）
5. **实现** `seek(timeSec)`：仅对 `file|url` 生效，`stream` 禁用
6. **实现** `setLoop(loop)`：仅 `file|url` 生效，`stream` 强制 false
7. **持久化**：

   * setVolume 时写 `newliveweb:audio:trackVolume`
   * loadInputDevice 成功后写 `newliveweb:audio:inputDeviceId`
   * 每次切源写 `newliveweb:audio:preferredSource`（file/url/stream）
8. **统一 snapshot**：`getSnapshot()` 必须包含 `currentSource` 与 `inputSourceInfo`
9. **resumeContext()**：若 context suspended，必须可恢复（用户首击）
10. **frame loop**：AudioBus 启动时确保只启动一次循环（避免重复 listeners）

## A3. 验收标准

* [!] 打开页面 → `audioBus.audioContextState` 不为 `uninitialized`（首次点击后可 resume）
* [!] `loadInputDevice()` 成功后：

  * `audioBus.currentSource === 'stream'`
  * `audioBus.inputSourceInfo.label` 有值（或至少为 opts.label/device label）
  * localStorage 写入 `preferredSource=stream`、`inputDeviceId=<id>`
* [!] stream 模式：

  * `seek()` 无效且不报错（直接 return）
  * `duration` 为 `0` 或 `NaN`（择一，但 UI 可判断）
  * `setLoop(true)` 不生效（保持 false）
* [!] file/url 模式：

  * seek 可用且不会导致 frame loop 中断
  * loop 可切换
* [!] `onFrame/subscribe` 订阅收到 `AudioFrame` 持续输出（>=30fps 或按你 processor 频率）

## A4. 最小 Patch 片段（AudioBus.ts）

> 说明：下面是“可直接粘贴的最小 diff”。如果你的 AudioBus/processor API 名称不同，按同意图改名即可。

```diff
*** a/src/audio/AudioBus.ts
--- b/src/audio/AudioBus.ts
@@
 export type StreamKind = 'default' | 'device' | 'display' | 'unknown';
 export type AudioSourceKind = 'file' | 'url' | 'stream' | null;

 export interface InputSourceInfo {
   deviceId: string | null;
   label: string | null;
   kind: StreamKind;
 }

 export class AudioBus {
+  // ===== stream meta =====
+  public streamLabel: string | null = null;
+  public streamDeviceId: string | null = null;
+  public streamKind: StreamKind = 'unknown';
+  public currentSource: AudioSourceKind = null;

   public ready = false;
   public latestFrame: AudioFrame | null = null;

   private listeners = new Set<AudioFrameListener>();
   private rafId: number | null = null;

   constructor(private processor: StreamAudioProcessor) {
+    // init volume from localStorage
+    const v = safeParseNumber(localStorage.getItem('newliveweb:audio:trackVolume'));
+    if (typeof v === 'number') this.processor.setVolume?.(clamp01(v));
   }

   get isReady() { return this.ready; }
   get isPlaying() { return this.processor.isPlaying?.() ?? false; }
   get currentTime() { return this.processor.currentTime?.() ?? 0; }
-  get duration() { return this.processor.duration?.() ?? 0; }
+  get duration() {
+    // stream has no stable duration
+    if (this.currentSource === 'stream') return 0;
+    return this.processor.duration?.() ?? 0;
+  }
   get audioContextState() { return this.processor.audioContextState?.() ?? 'uninitialized'; }
+  get inputSourceInfo(): InputSourceInfo {
+    return {
+      deviceId: this.streamDeviceId,
+      label: this.streamLabel,
+      kind: this.streamKind,
+    };
+  }

   public async resumeContext(): Promise<void> {
     await this.processor.resumeContext?.();
   }

@@
   public onFrame(listener: AudioFrameListener) {
     this.listeners.add(listener);
     this.ensureLoop();
     return () => this.listeners.delete(listener);
   }
   public subscribe(cb: (frame: AudioFrame) => void) { return this.onFrame(cb); }

   private ensureLoop() {
     if (this.rafId != null) return;
     const tick = () => {
       const f = this.processor.getFrame?.() ?? null;
       if (f) {
         this.latestFrame = f;
         for (const l of this.listeners) l(f);
       }
       this.rafId = requestAnimationFrame(tick);
     };
     this.rafId = requestAnimationFrame(tick);
   }

+  private setPreferredSource(kind: AudioSourceKind) {
+    if (!kind) return;
+    localStorage.setItem('newliveweb:audio:preferredSource', kind);
+  }

   public setVolume(volume: number) {
     const v = clamp01(volume);
     this.processor.setVolume?.(v);
+    localStorage.setItem('newliveweb:audio:trackVolume', String(v));
   }

   public setLoop(loop: boolean) {
-    this.processor.setLoop?.(loop);
+    // stream: force false
+    if (this.currentSource === 'stream') {
+      this.processor.setLoop?.(false);
+      return;
+    }
+    this.processor.setLoop?.(!!loop);
   }

   public seek(timeSec: number) {
-    this.processor.seek?.(timeSec);
+    if (this.currentSource === 'stream') return;
+    this.processor.seek?.(Math.max(0, timeSec));
   }

+  public async loadInputDevice(deviceId?: string): Promise<void> {
+    await this.resumeContext();
+    // choose deviceId: explicit > localStorage > default(undefined)
+    const saved = localStorage.getItem('newliveweb:audio:inputDeviceId') || undefined;
+    const did = deviceId ?? saved;
+
+    const stream = await navigator.mediaDevices.getUserMedia({
+      audio: did ? { deviceId: { exact: did } } : true,
+      video: false,
+    });
+
+    // label requires permission granted; derive label
+    const track = stream.getAudioTracks()[0];
+    this.streamLabel = track?.label || (did ? `Audio Device (${did.slice(0,6)}…)` : 'Default Audio Input');
+    this.streamDeviceId = did ?? null;
+    this.streamKind = did ? 'device' : 'default';
+
+    await this.loadMediaStream(stream, { label: this.streamLabel });
+    if (did) localStorage.setItem('newliveweb:audio:inputDeviceId', did);
+  }
+
+  public async loadMediaStream(stream: MediaStream, opts?: { label?: string }): Promise<void> {
+    await this.resumeContext();
+    await this.processor.loadMediaStream?.(stream);
+    this.ready = true;
+    this.currentSource = 'stream';
+    this.setPreferredSource('stream');
+    if (opts?.label) this.streamLabel = opts.label;
+    this.ensureLoop();
+  }

   public async loadFile(file: File): Promise<void> {
     await this.resumeContext();
     await this.processor.loadFile?.(file);
     this.ready = true;
+    this.currentSource = 'file';
+    this.streamLabel = null;
+    this.streamDeviceId = null;
+    this.streamKind = 'unknown';
+    this.setPreferredSource('file');
     this.ensureLoop();
   }

   public async loadUrl(url: string): Promise<void> {
     await this.resumeContext();
     await this.processor.loadUrl?.(url);
     this.ready = true;
+    this.currentSource = 'url';
+    this.streamLabel = null;
+    this.streamDeviceId = null;
+    this.streamKind = 'unknown';
+    this.setPreferredSource('url');
     this.ensureLoop();
   }

   public getSnapshot(): AudioFrame | null {
     return this.latestFrame;
   }

   public dispose() {
     if (this.rafId != null) cancelAnimationFrame(this.rafId);
     this.rafId = null;
     this.listeners.clear();
     this.processor.dispose?.();
   }
 }

+function clamp01(x: number) { return Math.max(0, Math.min(1, x)); }
+function safeParseNumber(v: string | null): number | null {
+  if (!v) return null;
+  const n = Number(v);
+  return Number.isFinite(n) ? n : null;
+}
```

---

# 2) Task B：bootstrap runtime coupling（只做 render-time patch，不改 state）

## B1. 修改文件

* `src/bootstrap.ts`

## B2. TODO 清单

1. 引入一个统一的 **RuntimePatch**（临时值）对象：`pm/liquid/depth` 的本帧参数
2. 把 `AudioCouplingAmounts` 应用到 runtime patch：

   * `projectm.energyToOpacityAmount` 动态
   * `liquid.timeScale / glow / iterations` 动态
   * `depth.layers / noise / fog` 动态
3. 把 Portrait Edge Coupling 注入 runtime patch（不动 state）
4. 加一个 **Silence Guard**：`frame.isSilent` 或 `energy < threshold` 时强制降级（省资源、防抖）
5. 给 Focus/Normal 模式加一个 runtime switch（不引依赖）：

   * Focus：降低 UI 干扰 + 强化背景一致性（例如固定 blend/收敛 glow）
   * Normal：按当前宏系统输出

## B3. 验收标准

* [!] 切换 Focus/Normal 时：不会抖动、不会重置 state（只改 runtime）
* [!] 静音时 GPU/CPU 压力显著下降（iterations/layers 降低）
* [!] coupling amount=0 时：输出与 base 参数一致
* [!] coupling amount=1 时：能明显看到跟随音频变化

## B4. 最小 Patch 片段（bootstrap.ts）

> 你项目实际结构不同的话，把“runtime patch”放到你渲染前的那一步。

```diff
*** a/src/bootstrap.ts
--- b/src/bootstrap.ts
@@
 import { computeMacroPatch } from './macro/computeMacroPatch';

+type RuntimePatch = {
+  pm: {
+    opacity: number;
+    energyToOpacityAmount: number;
+    blendMode?: any;
+    avgLumaSampling?: boolean;
+  };
+  liquid: {
+    timeScale: number;
+    iterations: number;
+    glowIntensity: number;
+    metallicAmount: number;
+    waveAmplitude: number;
+    tintHue?: number;
+    tintBrightness?: number;
+  };
+  depth: {
+    fog: number;
+    edge: number;
+    blur: number;
+    noise: number;
+    layers: number;
+    scale: number;
+    fall: number;
+  };
+};
+
+function scale(base: number, target: number, amount: number) {
+  const a = Math.max(0, Math.min(1, amount));
+  return base + (target - base) * a;
+}
+function clamp(x:number, a:number, b:number){ return Math.max(a, Math.min(b, x)); }
+function lerp(a:number,b:number,t:number){ return a+(b-a)*t; }

@@
 audioBus.onFrame((frame) => {
   // base state (from UI/store)
   const macro = computeMacroPatch(state.macros, state.layers, frame);

+  // build runtime patch from base+macro
+  const rt: RuntimePatch = {
+    pm: {
+      opacity: clamp(macro.projectmOpacity, 0, 1),
+      energyToOpacityAmount: clamp(macro.projectmEnergyToOpacityAmount ?? state.projectm.energyToOpacityAmount, 0, 1),
+      blendMode: macro.projectmBlendMode ?? state.projectm.blendMode,
+      avgLumaSampling: state.projectm.avgLumaSampling,
+    },
+    liquid: {
+      timeScale: clamp(macro.liquidTimeScale, 0, 2),
+      iterations: clamp(Math.round(macro.liquidIterations ?? state.liquid.iterations), 1, 8),
+      glowIntensity: clamp(macro.liquidGlowIntensity ?? state.liquid.glowIntensity, 0, 1),
+      metallicAmount: clamp(macro.liquidMetallicAmount, 0, 1),
+      waveAmplitude: clamp(macro.liquidWaveAmplitude ?? state.liquid.waveAmplitude, 0, 1),
+      tintHue: macro.liquidTintHue ?? state.liquid.tintHue,
+      tintBrightness: macro.liquidTintBrightness ?? state.liquid.tintBrightness,
+    },
+    depth: {
+      fog: clamp(macro.depthFog ?? state.depth.fog, 0, 1),
+      edge: clamp(macro.depthEdge, 0, 1),
+      blur: clamp(macro.depthBlur ?? state.depth.blur, 0, 1),
+      noise: clamp(macro.depthNoise ?? state.depth.noise, 0, 1),
+      layers: clamp(Math.round(macro.depthLayers), 1, 8),
+      scale: clamp(macro.depthScale ?? state.depth.scale, 0.5, 2),
+      fall: clamp(macro.depthFall ?? state.depth.fall, 0, 2),
+    },
+  };
+
+  // ===== Audio Coupling Runtime (no state mutation) =====
+  const e = clamp(frame.energy ?? 0, 0, 1);
+  const low = clamp((frame.bands?.low ?? 0) / 255, 0, 1);
+  const mid = clamp((frame.bands?.mid ?? 0) / 255, 0, 1);
+  const high = clamp((frame.bands?.high ?? 0) / 255, 0, 1);
+
+  const aPm = clamp(state.audioCouplingAmounts?.projectm ?? 0, 0, 1);
+  const aLq = clamp(state.audioCouplingAmounts?.liquid ?? 0, 0, 1);
+  const aDp = clamp(state.audioCouplingAmounts?.depth ?? 0, 0, 1);
+
+  // PM: energy -> opacity sensitivity
+  rt.pm.energyToOpacityAmount = clamp(
+    scale(rt.pm.energyToOpacityAmount, rt.pm.energyToOpacityAmount + e * 0.45, aPm),
+    0, 1
+  );
+
+  // Liquid: timeScale reacts to energy + highs
+  rt.liquid.timeScale = clamp(
+    scale(rt.liquid.timeScale, rt.liquid.timeScale * (1 + e * 0.35 + high * 0.25), aLq),
+    0, 2
+  );
+  rt.liquid.glowIntensity = clamp(
+    scale(rt.liquid.glowIntensity, rt.liquid.glowIntensity + high * 0.35, aLq),
+    0, 1
+  );
+  // Depth: layers/noise reacts to mid+low
+  rt.depth.layers = clamp(
+    Math.round(scale(rt.depth.layers, rt.depth.layers + mid * 3, aDp)),
+    1, 8
+  );
+  rt.depth.noise = clamp(
+    scale(rt.depth.noise, rt.depth.noise + low * 0.25, aDp),
+    0, 1
+  );
+
+  // ===== Portrait Edge Coupling (runtime only) =====
+  const edge01 = clamp(state.portrait?.edge01 ?? 0, 0, 1);
+  const edgeStrength = clamp(state.portrait?.edgeCouplingStrength ?? 0, 0, 1);
+  rt.pm.energyToOpacityAmount = clamp(
+    rt.pm.energyToOpacityAmount + edge01 * 0.45 * edgeStrength,
+    0, 1
+  );
+  rt.pm.opacity = clamp(
+    rt.pm.opacity + edge01 * 0.18 * edgeStrength,
+    0, 1
+  );
+
+  // ===== Silence Guard (performance + stability) =====
+  const silent = !!frame.isSilent || e < 0.02;
+  if (silent) {
+    rt.liquid.iterations = Math.min(rt.liquid.iterations, 2);
+    rt.depth.layers = Math.min(rt.depth.layers, 2);
+    rt.liquid.glowIntensity = Math.min(rt.liquid.glowIntensity, 0.15);
+  }
+
+  // ===== Focus/Normal switch (runtime only) =====
+  if (state.ui?.mode === 'Focus') {
+    rt.liquid.glowIntensity = Math.min(rt.liquid.glowIntensity, 0.35);
+    rt.pm.opacity = Math.min(rt.pm.opacity, 0.88);
+    rt.depth.noise = Math.min(rt.depth.noise, 0.35);
+  }
+
-  renderer.render(state.layers, macro, frame);
+  renderer.render(state.layers, macro, frame, rt);
 });
```

> 备注：`renderer.render(..., rt)` 如果你还没这个参数，就先加一个可选参数，不破坏旧调用。

---

# 3) Task C：computeMacroPatch —— “演出级宏矩阵” + Overlay Budget 稳定化

## C1. 修改文件

* `src/macro/computeMacroPatch.ts`

## C2. TODO 清单（核心）

1. **宏旋钮曲线**：把 `fusion/motion/sparkle` 从线性变为“更像旋钮”的响应曲线

   * `s-curve` / `smoothstep` / `expo`（轻量自写）
2. **Overlay Budget**：把你文档公式落地 + 增加“反抖动/反爆亮”

   * `maxEnergy_adjusted` + priority exponent
   * 加一个 `energyLimiter`（软削峰，不让极端能量把参数推爆）
3. 输出 `MacroPatch` 必须包含（至少）：

   * `projectmOpacity`
   * `projectmBlendMode`
   * `liquidTimeScale`
   * `liquidMetallicAmount`
   * `depthLayers`
   * `depthEdge`
   * `pmRetreatStrength`（预算用）
4. 让 `slot[0..4]` 按你文档固定映射（其余保留）

## C3. 验收标准

* [!] 宏旋钮 0~1 推动时：变化更“像设备旋钮”，0.5 附近更细腻
* [!] 大能量输入下：不会全层一起爆（预算系统有效）
* [!] `fusion>0.5` 时：PM 存在，背景退让明显但不黑（可控）
* [!] slot 映射符合表格（slot0→pm opacity，slot1→depth layers，slot2→metallic，slot3→timeScale，slot4→depth edge）

## C4. 最小 Patch 片段（computeMacroPatch.ts）

```diff
*** a/src/macro/computeMacroPatch.ts
--- b/src/macro/computeMacroPatch.ts
@@
 export function computeMacroPatch(macros, layersState, frame: AudioFrame): MacroPatch {
-  const fusion = macros.fusion ?? 0;
-  const motion = macros.motion ?? 0;
-  const sparkle = macros.sparkle ?? 0;
+  const fusion = knob(macros.fusion ?? 0);
+  const motion = knob(macros.motion ?? 0);
+  const sparkle = knob(macros.sparkle ?? 0);
   const slot = macros.slot ?? Array(8).fill(0);

+  const energy = clamp(frame.energy ?? 0, 0, 1);
+  const e = softLimit(energy, 0.92); // anti-explode
+
   // base params (from layerState)
   const pmBaseOpacity = layersState.projectm.opacity ?? 0.85;
   const pmBaseEnergyAmt = layersState.projectm.energyToOpacityAmount ?? 0.0;

   const liBaseTimeScale = layersState.liquid.timeScale ?? 1.0;
   const liBaseMetallic = layersState.liquid.metallicAmount ?? 0.7;

   const dpBaseLayers = layersState.depth.layers ?? 3;
   const dpBaseEdge = layersState.depth.edge ?? 0.5;

+  // === Macro matrix (per your spec) ===
+  const pmRetreatStrength = clamp(layersState.overlay?.pmRetreatStrength ?? 0.45, 0, 1);
+  const maxEnergy = clamp(layersState.overlay?.maxEnergy ?? 1.15, 1.0, 1.3);
+  const targetScale = clamp(layersState.overlay?.targetScale ?? 1.0, 0.5, 2.0);
+
+  const pmPresence01 = clamp((fusion - 0.5) * 2, 0, 1);
+  const maxEnergyAdjusted = maxEnergy * (1 - pmRetreatStrength * pmPresence01);
+
+  // allocate "visual energy" budget
+  // NOTE: use weighted shares, then compress by priority exponent
+  const pPM = 1.0, pLQ = 0.8, pDP = 0.65;
+  const wPM = pPM, wLQ = pLQ, wDP = pDP;
+  const wSum = wPM + wLQ + wDP;
+  const sharePM = wPM / wSum;
+  const shareLQ = wLQ / wSum;
+  const shareDP = wDP / wSum;
+
+  const ePM = clamp(maxEnergyAdjusted * sharePM, 0, 2);
+  const eLQ = clamp(maxEnergyAdjusted * shareLQ, 0, 2);
+  const eDP = clamp(maxEnergyAdjusted * shareDP, 0, 2);
+
+  const sPM = compress(ePM, pPM, targetScale);
+  const sLQ = compress(eLQ, pLQ, targetScale);
+  const sDP = compress(eDP, pDP, targetScale);
+
+  // PM opacity: base + fusion + slot0, then budget compress
+  const projectmOpacity =
+    clamp((pmBaseOpacity + fusion * 0.15 + (slot[0] ?? 0) * 0.18) * sPM, 0, 1);
+
+  // BlendMode heuristic: fusion high -> screen/add, else normal/multiply
+  const projectmBlendMode =
+    fusion > 0.85 ? 'screen' :
+    fusion > 0.65 ? 'add' :
+    fusion < 0.18 ? 'multiply' :
+    'normal';
+
+  // Liquid time scale: base + motion + slot3 + bpm-ish (optional later)
+  const liquidTimeScale =
+    clamp((liBaseTimeScale + motion * 0.6 + (slot[3] ?? 0) * 0.25) * (1 + e * 0.12) * sLQ, 0, 2);
+
+  // Metallic: base + sparkle + slot2, coupled with depth.fog later in bootstrap
+  const liquidMetallicAmount =
+    clamp((liBaseMetallic + sparkle * 0.25 + (slot[2] ?? 0) * 0.22) * sLQ, 0, 1);
+
+  // Depth layers: base + motion + slot1
+  const depthLayers =
+    clamp(Math.round((dpBaseLayers + motion * 6 + (slot[1] ?? 0) * 4) * (0.85 + e * 0.3) * sDP), 1, 8);
+
+  // Depth edge: base + sparkle + slot4
+  const depthEdge =
+    clamp((dpBaseEdge + sparkle * 0.15 + (slot[4] ?? 0) * 0.18) * sDP, 0, 1);
+
+  // PM sensitivity (energyToOpacityAmount): base + (budget + fusion)
+  const projectmEnergyToOpacityAmount =
+    clamp(pmBaseEnergyAmt + fusion * 0.12 + e * 0.08, 0, 1);
+
   return {
-    // TODO old fields...
+    projectmOpacity,
+    projectmBlendMode,
+    projectmEnergyToOpacityAmount,
+    liquidTimeScale,
+    liquidMetallicAmount,
+    depthLayers,
+    depthEdge,
+    pmRetreatStrength,
   };
 }
+
+function clamp(x:number,a:number,b:number){ return Math.max(a, Math.min(b, x)); }
+function knob(x:number){
+  // smoothstep-ish s-curve for tactile knob feel
+  const t = clamp(x,0,1);
+  return t*t*(3-2*t);
+}
+function softLimit(x:number, knee:number){
+  // soft-knee limiter: below knee linear, above knee compress
+  const t = clamp(x,0,1);
+  if (t <= knee) return t;
+  const over = (t - knee) / (1 - knee);
+  return knee + (1 - knee) * (over / (1 + over)); // asymptotic
+}
+function compress(e:number, priority:number, targetScale:number){
+  // priority: higher = less compressed
+  const base = clamp(e, 0, 2);
+  const expo = (1 / priority) * targetScale;
+  return Math.pow(clamp(base, 0, 1.25), expo); // keep in reasonable range
+}
```

---

# 4) Task D：酷炫算法（轻量、演出稳、直接落地）

> 你要求“根据参数信息深度思考 + 创造酷炫算法”，我给你 4 套：每套都能用你现有的 `AudioFrame + 宏 + 层参数` 实现，且不加依赖。

---

## D1) “银色呼吸辉光”算法（全局能量呼吸 + 高频闪烁抑制）

**目标**：让整体有“银色光泽呼吸”，但不会因为高频尖峰闪烁刺眼。
**实现位置**：`bootstrap.ts` runtime patch
**核心**：

* `breath = 0.5 + 0.5*sin(t * (0.6 + motion*1.2))`
* 用 `energy` 驱动亮度，但对 `high` 做抑制（软削峰）
* 作用到：`liquid.glowIntensity`、`pm.opacity` 的微量增益（很小！）

Patch（加在 bootstrap runtime 中）：

```ts
const t = frame.timeSec ?? performance.now()/1000;
const breath = 0.5 + 0.5 * Math.sin(t * (0.6 + (state.macros?.motion ?? 0) * 1.2));
const highSoft = softLimit(high, 0.75);
rt.liquid.glowIntensity = clamp(rt.liquid.glowIntensity + breath*0.06 + highSoft*0.08, 0, 1);
rt.pm.opacity = clamp(rt.pm.opacity + breath*0.03, 0, 1);
```

---

## D2) “能量惯性 + 打击瞬态”算法（稳定跟随 + 击打触发）

**目标**：能量不抖，同时保留 kick/snare 的瞬态冲击。
**实现位置**：`AudioFrame.energy` 的后处理（若你能改 processor 输出最好；否则在 bootstrap 里维护一个滤波状态）
**核心**：

* `energySlow = EMA(energy, alphaSlow)`
* `energyFast = EMA(energy, alphaFast)`
* `hit = clamp(energyFast - energySlow, 0..1)` 作为“击打信号”

作用：

* `hit` 驱动 `depth.edge`、`liquid.iterations` 的瞬时提升
* `energySlow` 驱动整体流速/雾

Patch（bootstrap 内部维护闭包状态）：

```ts
// module-scope state
let eSlow = 0, eFast = 0;
function ema(prev:number, x:number, a:number){ return prev + (x-prev)*a; }

// per frame
eSlow = ema(eSlow, e, 0.06);
eFast = ema(eFast, e, 0.25);
const hit = clamp(eFast - eSlow, 0, 1);

rt.depth.edge = clamp(rt.depth.edge + hit * 0.22, 0, 1);
rt.liquid.iterations = clamp(rt.liquid.iterations + Math.round(hit * 2), 1, 8);
rt.depth.fog = clamp(rt.depth.fog + eSlow * 0.08, 0, 1);
```

---

## D3) “雾-金属反馈环”算法（depth.fog ↔ liquid.metallic ↔ pm.sensitivity）

**目标**：你拟新增耦合落地成一个“反馈环”，画面会出现很“活”的相变。
**实现位置**：bootstrap runtime patch（你文档里就写了）
**核心**（你给的系数落地 + 加稳定钳制）：

* `liquid.metallic += depth.fog * 0.3`
* `pm.energyToOpacityAmount += depth.fog * 0.25`

Patch：

```ts
rt.liquid.metallicAmount = clamp(rt.liquid.metallicAmount + rt.depth.fog * 0.30, 0, 1);
rt.pm.energyToOpacityAmount = clamp(rt.pm.energyToOpacityAmount + rt.depth.fog * 0.25, 0, 1);
```

---

## D4) “空间扭曲级联”算法（liquid.wave → depth.scale + depth.blur + fall）

**目标**：波浪越大，空间越扭曲、下落越快，形成“金属液体把空间拖拽”的感觉。
**实现位置**：bootstrap runtime patch
**核心**（你拟新增耦合 + 稳定项）：

```ts
rt.depth.scale = clamp(rt.depth.scale * (1 + rt.liquid.waveAmplitude * 0.30), 0.5, 2);
rt.depth.blur = clamp(rt.depth.blur + rt.liquid.waveAmplitude * 0.20, 0, 1);
rt.depth.fall = clamp(rt.depth.fall + rt.liquid.waveAmplitude * 0.15, 0, 2);
```

---

# 5) Task E：把“Focus/Normal 两模式”做成可控的“演出保护壳”

## E1. 修改文件

* `src/bootstrap.ts`（runtime patch 已支持）
* （可选）`src/ui/*`：只需要 `state.ui.mode = 'Focus'|'Normal'` 能切即可

## E2. TODO

* Focus：

  * 限制 glow、限制 iterations、限制 depth.layers（防掉帧）
  * 降低 UI 干扰（你已有 UI 最小化机制的话仅切 state）
* Normal：

  * 放开所有宏与耦合

## E3. 验收

* [!] Focus 打开后帧率明显更稳
* [!] 不影响音频播放、不会重置 audio bus

---

# 6) Codex 一键执行顺序（必须按这个来）

1. 应用 **Task A**（AudioBus 最小闭环）
2. 应用 **Task C**（computeMacroPatch：宏曲线 + 预算）
3. 应用 **Task B**（bootstrap runtime patch 管线）
4. 加入 **Task D** 4 套酷炫算法（都在 bootstrap runtime 中）
5. 加 **Task E** Focus/Normal 演出保护壳
6. 最后跑一次全链路自测

---

# 7) 自测脚本（无依赖，靠浏览器行为 + 控制台断言）

## 7.1 手动验收 checklist（给 Codex 也能读）

* file：

  * loadFile → currentSource=file → duration>0 → seek 可用
* url：

  * loadUrl → currentSource=url → duration>0（若可得）→ seek 可用
* stream：

  * loadInputDevice → currentSource=stream → duration=0 → seek disabled
* 任意模式：

  * `audioBus.getSnapshot()` 返回 frame 且 energy 在 0..1
  * 静音时（energy<0.02）iterations/layers 自动降级
* Focus/Normal：

  * Focus 下 glow/iterations/layers 受限，帧率更稳

---

# 8) 你现在需要把这些交给 Codex 的输入（直接复制即可）

把本回复整段丢给 Codex，并附加一句：

* “按顺序执行 Task A→C→B→D→E；所有 patch 以最小改动落地；如果文件路径不同，先全局搜索类名/函数名定位后再打补丁；保证 TS 编译通过。”

---
---

# 1) 先补一个“控制学底座”：三路信号分解 + 稳定器

> 你现在的 AudioFrame 提供 `energy(0..1) + bands(0..255) + rms/peak`，最容易出问题的是：
> **能量跳变导致参数抖动**、以及 **高频尖峰导致闪烁/爆亮**。
> 所以先做“三路信号”：**慢速(情绪)** / **快速(节奏)** / **瞬态(打击)**。

在 `bootstrap.ts`（module-scope）加这组状态（轻量）：

```ts
let eSlow = 0, eFast = 0, ePeakHold = 0;
let lowSlow=0, midSlow=0, highSlow=0;
let hitGate = 0;

function clamp(x:number,a:number,b:number){ return Math.max(a, Math.min(b, x)); }
function ema(prev:number, x:number, a:number){ return prev + (x-prev)*a; }
function softLimit(x:number,knee=0.8){
  x = clamp(x,0,1);
  if (x<=knee) return x;
  const over=(x-knee)/(1-knee);
  return knee + (1-knee)*(over/(1+over));
}
```

每帧更新（在 `onFrame` 里）：

```ts
const e = clamp(frame.energy ?? 0, 0, 1);
const low  = clamp((frame.bands?.low  ?? 0)/255, 0, 1);
const mid  = clamp((frame.bands?.mid  ?? 0)/255, 0, 1);
const high = clamp((frame.bands?.high ?? 0)/255, 0, 1);

eSlow = ema(eSlow, e, 0.05);      // 情绪/氛围
eFast = ema(eFast, e, 0.22);      // 节奏/律动
const hit = clamp(eFast - eSlow, 0, 1);  // 瞬态
hitGate = ema(hitGate, hit > 0.08 ? 1 : 0, 0.18); // 打击门限（稳）

lowSlow  = ema(lowSlow,  low,  0.06);
midSlow  = ema(midSlow,  mid,  0.06);
highSlow = ema(highSlow, high, 0.06);

// 峰值保持（避免亮度瞬间掉光）
ePeakHold = Math.max(ePeakHold * 0.92, e);
```

### 验收（你用肉眼也能判断）

* 静态/环境音乐：画面持续“呼吸”，不会抖
* Kick/鼓点：会有明显“击打特效”但不乱闪
* 高频尖峰：发光不刺眼、不爆白

---

# 2) “Overlay Budget 2.0”：竞争不是固定权重，而是“场景优先级随 fusion 改变”

你现在的预算逻辑是：PM 优先级最高，Depth最低。
但演出里更爽的是：**fusion 改变“主舞台”是谁**：

* `fusion < 0.35`：Liquid 主舞台（更像“VJ 背景”）
* `0.35 ~ 0.7`：三者平衡
* `fusion > 0.7`：ProjectM 主舞台（更像“主视觉”），Depth 退居空间层

在 `computeMacroPatch.ts` 里，把 priorities 变成函数：

```ts
function dynPriority(fusion:number){
  // fusion 0..1
  const pm = 0.75 + fusion*0.45;        // 0.75..1.20
  const lq = 1.05 - fusion*0.25;        // 1.05..0.80
  const dp = 0.70 + (1-Math.abs(fusion-0.5)*2)*0.10; // 中间略抬
  return { pm, lq, dp };
}
```

然后 `compress()` 用动态 priority。效果：
**fusion 旋钮真正成为“舞台导演”**，不是单纯加 opacity。

### 验收

* 你转 fusion，会感觉“主视觉角色切换”，而不是同一套画面换透明度

---

# 3) “三宏旋钮”的非线性更精细：每个宏用不同曲线

你现在用统一 s-curve。更细：

* `fusion`：中段更细腻（控制主视觉权重）
* `motion`：后段更敏感（越后越快）
* `sparkle`：前段就有效（轻轻拧就有高光）

```ts
function curveFusion(x:number){ x=clamp(x,0,1); return x*x*(3-2*x); } // smoothstep
function curveMotion(x:number){ x=clamp(x,0,1); return Math.pow(x, 1.6); } // 后段敏感
function curveSparkle(x:number){ x=clamp(x,0,1); return 1 - Math.pow(1-x, 2.2); } // 前段有效
```

用这三条替换原来的 `knob()`。

### 验收

* motion 旋钮“越拧越疯”，sparkle “轻拧就亮”，fusion “中段更细”

---

# 4) 你要的“酷炫算法”：给你 6 套可落地的“效果控制律”

下面每套都只改 runtime patch（bootstrap），不需要 shader 大改，也不会破坏稳定。

---

## 4.1 相位打击：Kick 触发“深度边缘闪断” + PM 敏感瞬间抬升

> 用 hit（瞬态）做“断续的边缘刀光”，很 Cyber。

```ts
const hit01 = clamp(hit*1.8, 0, 1);
rt.depth.edge = clamp(rt.depth.edge + hit01*0.35, 0, 1);
rt.pm.energyToOpacityAmount = clamp(rt.pm.energyToOpacityAmount + hit01*0.22, 0, 1);
```

可选加“闪断节拍”：只在门限打开时触发一次尖峰（防乱闪）：

```ts
const strobe = hitGate > 0.6 ? 1 : 0;
rt.liquid.glowIntensity = clamp(rt.liquid.glowIntensity + strobe*0.12, 0, 1);
```

---

## 4.2 频段“材质切换”：低频→更液态，中频→更深度，高频→更金属

你已经有参数映射，但现在把它做成“材料学”：

* 低频：增 waveAmplitude + blur（像液体震荡）
* 中频：增 depth.layers + noise（像空间密度）
* 高频：增 metallic + glow（像电镀闪光）

```ts
rt.liquid.waveAmplitude = clamp(rt.liquid.waveAmplitude + lowSlow*0.18, 0, 1);
rt.depth.layers = clamp(Math.round(rt.depth.layers + midSlow*2), 1, 8);
rt.depth.noise = clamp(rt.depth.noise + midSlow*0.18, 0, 1);
rt.liquid.metallicAmount = clamp(rt.liquid.metallicAmount + highSlow*0.22, 0, 1);
rt.liquid.glowIntensity = clamp(rt.liquid.glowIntensity + softLimit(highSlow,0.75)*0.18, 0, 1);
```

---

## 4.3 “雾化反馈环”升级版：fog 不只是加 metallic，还控制 PM 退让（更像舞台灯）

你文档里 fog→PM敏感、fog→metallic。再加一条：**fog 高时 PM 退让**，画面更有纵深（像烟雾把背景吃掉）。

```ts
rt.liquid.metallicAmount = clamp(rt.liquid.metallicAmount + rt.depth.fog*0.30, 0, 1);
rt.pm.energyToOpacityAmount = clamp(rt.pm.energyToOpacityAmount + rt.depth.fog*0.25, 0, 1);

// fog 高 -> PM opacity 稍退，让 Depth/Liquid 出来（很“烟感”）
rt.pm.opacity = clamp(rt.pm.opacity * (1 - rt.depth.fog*0.18), 0, 1);
```

---

## 4.4 “能量惯性拖影”：用 ePeakHold 让亮度有惯性（更像灯控的 dimmer curve）

很多 VJ 爽感来自灯的“拖影感”。你有 `peak`，但我们用 `ePeakHold` 更稳：

```ts
const glowBase = rt.liquid.glowIntensity;
const glowTarget = clamp(glowBase + ePeakHold*0.22 - eSlow*0.10, 0, 1);
rt.liquid.glowIntensity = clamp(lerp(glowBase, glowTarget, 0.25), 0, 1);
```

效果：鼓点后光会“留一下”，不会立刻熄灭。

---

## 4.5 “空间扭曲级联”精细版：wave 驱动 scale/blur/fall，但加防爆阀

你文档里的级联很对，但需要防爆：wave 大时别把 blur 推满。

```ts
const w = rt.liquid.waveAmplitude;
rt.depth.scale = clamp(rt.depth.scale * (1 + w*0.28), 0.5, 2);
rt.depth.blur = clamp(rt.depth.blur + w*0.18*(1-rt.depth.blur), 0, 1); // 越接近1越难再涨
rt.depth.fall = clamp(rt.depth.fall + w*0.12, 0, 2);
```

---

## 4.6 “色相共振”落地：pm.avgLuma → liquid tint（你拟新增耦合）

你列了 avgLuma，但可能还没真正算。先按“如果有就用，没有就用 eSlow 代替”。

```ts
const avgLuma = clamp((state.projectm?.avgLuma ?? eSlow), 0, 1);
rt.liquid.tintHue = ((rt.liquid.tintHue ?? 180) + avgLuma*60) % 360;
rt.liquid.tintBrightness = clamp((rt.liquid.tintBrightness ?? 1.0) + avgLuma*0.4, 0, 2);
```

---

# 5) “BPM 级联耦合”的现实落地（不引依赖）：用击打 hit 做简易 tempo 估计

你想要 `bpm → liquid.timeScale / depth.layers`。
不用引库也能做一个 **稳定的“伪 BPM”**：统计 hitGate 的上升沿间隔。

module-scope：

```ts
let lastBeatT = 0;
let bpmEst = 120;
```

每帧：

```ts
const t = frame.timeSec ?? performance.now()/1000;
const beat = hitGate > 0.75; // 足够稳
// 简易上升沿：beat 从 false->true
// 需要额外保存上一帧beat状态
```

补一个状态：

```ts
let beatPrev = false;
```

检测：

```ts
if (beat && !beatPrev) {
  const dt = t - lastBeatT;
  if (dt > 0.25 && dt < 1.2) { // 50..240 BPM
    const bpm = 60 / dt;
    bpmEst = ema(bpmEst, bpm, 0.15); // 平滑
    lastBeatT = t;
  }
}
beatPrev = beat;
```

应用级联（你给的公式）：

```ts
const bpmNorm = clamp((bpmEst - 120)/120, -1, 1);
rt.liquid.timeScale = clamp(rt.liquid.timeScale * (1 + bpmNorm*0.30), 0, 2);
rt.depth.layers = clamp(rt.depth.layers + Math.floor((bpmEst - 120)/20), 1, 8);
```

### 验收

* House/Techno：timeScale 明显跟节奏快慢变化
* 不会因为一两个尖峰把 bpm 拉到离谱（dt 范围限制 + 平滑）

---

# 6) 最关键的“演出稳定策略”：参数变化速率限制（Rate Limiter）

> 这是让你系统“像硬件”一样稳的核心。
> 不做这个，再酷的耦合都会抖。

对关键参数做“每秒最大变化量限制”，放在 bootstrap runtime patch 最后：

module-scope 保存上一帧值：

```ts
let prev = {
  pmOpacity: 0.85,
  pmE2O: 0,
  lqTime: 1,
  lqGlow: 0.4,
  dpFog: 0.3,
  dpLayers: 3,
};
function rateLimit(prev:number, next:number, maxDeltaPerSec:number, dt:number){
  const maxD = maxDeltaPerSec * dt;
  const d = next - prev;
  if (d > maxD) return prev + maxD;
  if (d < -maxD) return prev - maxD;
  return next;
}
```

每帧计算 `dt`（用 `timeSec` 差，或 performance.now）：

```ts
let lastT = 0;
const nowT = frame.timeSec ?? performance.now()/1000;
const dt = lastT ? Math.max(0.001, nowT-lastT) : 1/60;
lastT = nowT;

rt.pm.opacity = rateLimit(prev.pmOpacity, rt.pm.opacity, 1.2, dt);         // 每秒最多变 1.2
rt.pm.energyToOpacityAmount = rateLimit(prev.pmE2O, rt.pm.energyToOpacityAmount, 2.0, dt);

rt.liquid.timeScale = rateLimit(prev.lqTime, rt.liquid.timeScale, 1.5, dt);
rt.liquid.glowIntensity = rateLimit(prev.lqGlow, rt.liquid.glowIntensity, 2.5, dt);

rt.depth.fog = rateLimit(prev.dpFog, rt.depth.fog, 0.9, dt);
rt.depth.layers = Math.round(rateLimit(prev.dpLayers, rt.depth.layers, 6.0, dt));

prev = {
  pmOpacity: rt.pm.opacity,
  pmE2O: rt.pm.energyToOpacityAmount,
  lqTime: rt.liquid.timeScale,
  lqGlow: rt.liquid.glowIntensity,
  dpFog: rt.depth.fog,
  dpLayers: rt.depth.layers,
};
```

### 验收

* 任何音乐：画面不会“抽搐式跳变”
* 强鼓点：仍然能冲击，但更像“灯控推子”

---

# 7) 你要的“Codex 可执行任务补丁”应该怎么加（最短指令）

把下面当成 Codex TODO（它会自动把上述算法按位置插入）：

* `bootstrap.ts`

  1. module-scope 增加 signal states：`eSlow/eFast/hitGate/ePeakHold/beatPrev/bpmEst/prev/lastT`
  2. 在 `onFrame` 内先更新三路信号与 bpm
  3. 在 runtime patch 构建后应用 4.1~4.6（按顺序）
  4. 最后做 rate limiter
* `computeMacroPatch.ts`

  1. 替换宏曲线：fusion/motion/sparkle 各自曲线
  2. 动态 priority：`dynPriority(fusion)`
  3. compress 使用动态 priority

---


## 未验证项目

- 本文件 checklist 均未做现场验证
